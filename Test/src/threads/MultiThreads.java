package threads;
/**
 * 言语文档说明
 * @author humaohua
 *
 */
public class MultiThreads {
/**
 * 
 * Java多线程入门

以下内容转自http://blog.sina.com.cn/guoyalun

如何创建和理解线程
    曾经在学习操作系统的时候，进程是一个重点内容，线程也学习过，但是没有什么深刻的印象。在Java多线程的学习中对线程有了一个全面而深刻的理解。一个进程可以包含一个或多个线程，一个线程就是一个程序内部的一条执行线索。

    创建多线程有两种方法：继承Thread类和实现Runnable接口。通过调用继承thread对象的start（）方法就可以调用该类中的run()方法。如果想要将一段代码在一个新的线程上运行时，该代码就应该位于一个类的run函数中，并且run()函数所在的类是Tread类的子类。启动一个新的线程不是直接调用子类的run方法，而是调用thread类的start方法，thread类的start方法将产生一个新的线程，并在新的线程上运行该thread类对象中的run方法。由于线程的代码段是在run方法中，那么该方法执行完以后，线程也就相应结束了。

    当使用Tread(Runnable target)方法创建线程对象时，需要为该方法传递一个实现了Runnable接口的对象，这样创建的线程将调用了那个实现了Runnable接口的类对象中的run()方法作为其运行代码，而不再调用Thread类中的run方法了。

    通过对这两种实现多线程的方法对比我们知道，实现Runnable接口相对于继承Thread类来说有以下几个优点：

   （1） 适合多个相同程序代码的线程去处理同一个资源的情况，把虚拟的CPU同程序的代码，数据有效分离。

   （2） 可以避免由于Java的单继承带来的局限性。

   （3） 有利于程序的健壮性，代码能够被多个线程共享，代码与数据时独立的。多个线程可以操作想相同的数据，与他们的代码无关。

    几乎所有的多线程都可以使用实现Runnable接口的方法实现。

    关于后台线程的概念就不在累述，关于如何设置后台进程就需要使用setDaemon方法。按照前面产生方式产生的线程都是前台线程，在一个线程对象启动之前调用了setDaemon(true)方法，这个线程就变成后台线程了，只有后台线程运行时程序就会结束。通过调用Thread类的join方法就可以把该线程合并到调用join语句的线程中。

    关于多线程的应用是十分广泛的。我们可以使用多线程来编写一个网络聊天程序，多线程编写的网络聊天程序才可以正确运行，而单线程的聊天程序，由于等待某件事件的发生常常会因互相等待而发生崩溃。关于www服务器就是一个多线程的很典型的例子，它可以为每一个访问者建立一个线程。

          

多线程的同步

    说句实在话，如果不是张老师讲解关于线程安全的问题，我还真是不懂什么叫线程安全。我们可以使用同步代码块和同步函数来实现线程安全。同步代码块就相当于一个独木桥，任何时候只允许一个线程在上面运行，这样就可以避免线程安全问题的产生。关于同步代码块我们使用synchronized(object){代码段}  张老师在本段的讲解中使用了通俗的讲解方法和专业的术语两种方式来讲解，比如锁旗标，线程池啊。讲解得已经非常详细了，在此我就不再累述了。在看看如何使用同步函数来实现线程之间同步。只需要在需要同步的函数前加上synchronized关键字就可以了。运行的结果与使用同步代码块是完全一样的。代码块和同步函数之间也可以实现同步的。只是我们需要寻找一个监视器对象放在同步代码块中，究竟这个监视器对象怎么样设置才是对的呢。在前面的学习中我们学习了一个非常有用的关键字对象，就是this，它给我们的编程带来了很大的方便，这里同步代码块和同步函数的同步实现也是通过使用this关键字来实现的。

    我记得在学习操作系统原理的时候，老师给我们重点讨论的一个问题就是死锁的问题。关于死锁的概念，死锁的产生条件，死锁的预防，死锁的检测，从原理上已经理解的非常清楚了。在这里我们通过编写程序，来进一步理解死锁的产生机制，以及如何避免死锁。因此在以后编写多线程的程序的时候，应该考虑到这一点，要预防死锁的产生。

            

线程间的通信(线程间交互)

    本节通过消费者生产者模型的问题引出了关于进程之间的通信。Java是通过object类的wait,notify,notifyAll这几个方法来实现线程之间的通信的。由于所有的类都是从object继承来的，因此在任何类中都可以直接使用这些方法。三个方法的简单说明如下：

Wait：告诉当前进程放弃监视器并进入睡眠状态，直到其他进程进入同一监视器并调用notify为止。

Notify：唤醒同一对象监视器中调用wait的第一个线程。

notifyAll：唤醒同一对象监视器中调用wait的所有线程，具有最高优先级的线程首先被唤醒并执行。

Wait,notify,notifyAll这三个方法只能在synchronized方法中调用，即无论线程调用一个对象的wait还是notify方法，该线程必须得到该对象的锁旗标。这样，notify只能唤醒同一对象监视器中调用wait的线程，使用多个对象监视器，我们就可以分组有多个wait，notify的情况，同组里的wait只能被同组的notify唤醒

   

线程生命的控制

    控制线程生命周期的方法有很多种，如：suspend方法，resume方法和stop方法。但是我们并不推荐使用这三个方法，主要是因为以下几点：

   （1）会导致死锁的发生。

   （2）它允许一个线程通过直接控制另外一个线程的代码来直接控制那个线程。

    虽然stop方法可以避免死锁，但会带来另外的不足，如果一个线程正在操作共享数据段，操作过程没有完成就stop的话，将会导致数据的不完整性。因此stop方法我们也不提倡使用。在实际的编程操作中我们推荐使用控制run方法中的循环条件的方式来结束一个线程，这也是实际情况中使用最多的。

    至此Java的多线程也就学习完毕，下面是关于多线程的一点总结信息。

    要认识多线程就要从操作系统的原理说起。多线程的目的是为了最大限度的利用CPU资源。Java编写程序都运行在在Java虚拟机（JVM）中，在JVM的内部，程序的多任务是通过线程来实现的。每用java命令启动一个java应用程序，就会启动一个JVM进程。在同一个JVM进程中，有且只有一个进程，就是它自己。

    Java 虚拟机允许应用程序并发地运行多个执行线程。Java语言提供了多线程编程的扩展点，并给出了功能强大的线程控制API。

    常见线程名词解释

    主线程：JVM调用程序mian()所产生的线程。

    当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。

    后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。

    前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。
    
    
    
 * Java多线程-概念与原理

一、操作系统中线程和进程的概念
现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。

进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。

线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。

“同时”执行是线程给人的感觉，在线程之间实际上是轮换执行。

二、Java中的线程
创建多线程的两种方式：继承Thread类和实现Runnable接口。

一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。

Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。

一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。

一旦创建一个新的线程，就产生一个新的调用栈。

线程总体分两类：用户线程和守候线程。
当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。


同步、异步、阻塞和非阻塞区别

简单点说:

阻塞就是干不完不准回来，一直处于等待中，直到事情处理完成才返回；
非阻塞就是你先干，我先看看有其他事没有，一发现事情被卡住，马上报告领导。

我们拿最常用的send和recv两个函数来说吧...
比如你调用send函数发送一定的Byte,在系统内部send做的工作其实只是把数据传输(Copy)到TCP/IP协议栈的输出缓冲区,它执行成功并不代表数据已经成功的发送出去了,如果TCP/IP协议栈没有足够的可用缓冲区来保存你Copy过来的数据的话...这时候就体现出阻塞和非阻塞的不同之处了:对于阻塞模式的socket send函数将不返回直到系统缓冲区有足够的空间把你要发送的数据Copy过去以后才返回,而对于非阻塞的socket来说send会立即返回WSAEWOULDDBLOCK告诉调用者说:"发送操作被阻塞了!!!你想办法处理吧..."

对于recv函数,同样道理,该函数的内部工作机制其实是在等待TCP/IP协议栈的接收缓冲区通知它说:嗨,你的数据来了.对于阻塞模式的socket来说如果TCP/IP协议栈的接收缓冲区没有通知一个结果给它它就一直不返回:耗费着系统资源....对于非阻塞模式的socket该函数会马上返回,然后告诉你:WSAEWOULDDBLOCK---"现在没有数据,回头在来看看"

扩展:

在进行网络编程时，我们常常见到同步、异步、阻塞和非阻塞四种调用方式。这些方式彼此概念并不好理解。下面是我对这些术语的理解。

1、同步

所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的LRESULT值返回给调用者。

2、异步

异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以 CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以向下运行。当连接真正建立起来以后，socket底 层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供 多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循 环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知 没太多区别。

3、阻塞

阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。

4、非阻塞

非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

对象的阻塞模式和阻塞函数调用

对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。


 */
}
